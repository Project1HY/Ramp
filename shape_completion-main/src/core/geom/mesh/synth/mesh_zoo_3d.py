import math
import numpy as np
from geom.mesh.op.cpu.remesh import subdivide
from numpy.linalg import norm
from numbers import Number
from geom.mesh.synth.helpers import _align_scale, _make_pair_range, _compose_from_faces, DEF_CENTER
from math import pi
from geom.matrix.cpu import cartesian_product
from geom.mesh.io.base import pyvista_mesh2numpy
import pyvista as pv


# Spheres can also be generated by refining the faces of platonic solids and then "inflating" them. meshzoo implements
# a few of them. The sphere generated from the icosahedron has the highest-quality (most equilateral) triangles.

# TODO - more cool parametric shpaes here: https://docs.pyvista.org/examples/00-load/create-parametric-geometric-objects.html
# ---------------------------------------------------------------------------------------------------------------------#
#
# ---------------------------------------------------------------------------------------------------------------------#
def box(width=1.0, height=1.0, depth=1.0):
    """
    :param width (float, optional, default=1.0) – x-directional length.
    :param height (float, optional, default=1.0) – y-directional length.
    :param depth (float, optional, default=1.0) – z-directional length.
    """
    import open3d
    M = open3d.geometry.TriangleMesh.create_box(width=width, height=height, depth=depth)
    v, f = np.asarray(M.vertices), np.asarray(M.triangles)
    return v, f


def uniform_grid(nx=20, ny=20, x_bounds=(-1, 1), y_bounds=(-1, 1), z_val=0, cell_type='edges'):
    # The grid has the vertex set [x] x [y]
    x = np.linspace(x_bounds[0], x_bounds[1], nx)
    y = np.linspace(y_bounds[0], y_bounds[1], ny)
    v = np.column_stack((cartesian_product(x, y), np.full((nx * ny, 1), z_val)))  # All 3D points

    if cell_type == 'edges':  # Two-cells, i.e. edges
        # TODO - vectorize this:
        # Horizontal edges: ( (i,j) , (i+1,j) ) for i in [x-1] and j in [y]
        cells = []
        for i in range(len(x) - 1):
            for j in range(len(y)):
                cells.append([i, j, i + 1, j])

        # Vertical edges: ( (i,j) , (i,j+1) ) for i in [x] an j in [y-1]
        for i in range(len(x)):
            for j in range(len(y) - 1):
                cells.append([i, j, i, j + 1])

        cells = np.asarray(cells)
        # Map the [x],[y] edges to world edges by the cartesian product relation
        cells[:, 0] = cells[:, 0] * len(y) + cells[:, 1]
        cells[:, 1] = cells[:, 2] * len(y) + cells[:, 3]
        cells = cells[:, :2]

        # Add the cell qualifer before each edge:
        # qualifier = np.full((cells.shape[0], 1), 2)
        # cells = np.hstack((qualifier, cells))

    elif cell_type == 'tris':
        cells = np.empty((nx - 1, ny - 1, 2, 3), dtype=int)

        r = np.arange(nx * ny).reshape(nx, ny)

        cells[:, :, 0, 0] = r[:-1, :-1]
        cells[:, :, 1, 0] = r[:-1, 1:]
        cells[:, :, 0, 1] = r[:-1, 1:]

        cells[:, :, 1, 1] = r[1:, 1:]
        cells[:, :, :, 2] = r[1:, :-1, None]

        cells.shape = (-1, 3)
        # Add the cell qualifer before each edge:
        # qualifier = np.full((cells.shape[0], 1), 3)
        # cells = np.hstack((qualifier, cells))


    elif cell_type == 'quads':
        raise NotImplementedError
    else:
        raise AssertionError(f"Unknown cell type {cell_type}")

    return v, cells


def cone(radius=1.0, height=2.0, resolution=20, split=1):
    """
    :param radius (float, optional, default=1.0) – The radius of the cone.
    :param height (float, optional, default=2.0) – The height of the cone.
            The axis of the cone will be from (0, 0, 0) to (0, 0, height).
    :param resolution (int, optional, default=20) – The circle will be split into resolution segments
    :param split (int, optional, default=1) – The height will be split into split segments.
    """
    import open3d
    M = open3d.geometry.TriangleMesh.create_cone(radius=radius, height=height, resolution=resolution, split=split)
    v, f = np.asarray(M.vertices), np.asarray(M.triangles)
    return v, f


def cylinder(radius=1.0, height=2.0, resolution=20, split=4):
    """
    :param: radius (float, optional, default=1.0) – The radius of the cylinder.
    :param height (float, optional, default=2.0) – The height of the cylinder.
        The axis of the cylinder will be from (0, 0, -height/2) to (0, 0, height/2).
    :param resolution (int, optional, default=20) – The circle will be split into resolution segments
    :param split (int, optional, default=4) – The height will be split into split segments.
    """
    import open3d
    M = open3d.geometry.TriangleMesh.create_cylinder(radius=radius, height=height, resolution=resolution, split=split)
    v, f = np.asarray(M.vertices), np.asarray(M.triangles)
    return v, f


def tube(length=1.0, radius=1.0, n=30):
    # Number of nodes along the width of the strip (>= 2)
    # Choose it such that we have approximately square boxes.
    nw = int(round(length * n / (2 * np.pi * radius)))

    # Generate suitable ranges for parametrization
    u_range = np.linspace(0.0, 2 * np.pi, num=n, endpoint=False)
    v_range = np.linspace(-0.5 * length, 0.5 * length, num=nw)

    # Create the vertices.
    proto_nodes = np.dstack(np.meshgrid(u_range, v_range, indexing="ij")).reshape(
        -1, 2
    )
    v = np.column_stack(
        [
            radius * np.cos(proto_nodes[:, 0]),
            radius * np.sin(proto_nodes[:, 0]),
            proto_nodes[:, 1],
        ]
    )

    # create the elements (cells)
    f = []
    for i in range(n - 1):
        for j in range(nw - 1):
            f.append([i * nw + j, (i + 1) * nw + j + 1, i * nw + j + 1])
            f.append([i * nw + j, (i + 1) * nw + j, (i + 1) * nw + j + 1])

    # close the geometry
    for j in range(nw - 1):
        f.append([(n - 1) * nw + j, j + 1, (n - 1) * nw + j + 1])
        f.append([(n - 1) * nw + j, j, j + 1])

    return v, np.array(f)


def tetrahedron(radius=1.0, center=DEF_CENTER):
    s = 1.0 / math.sqrt(2.0)
    v = np.array([
        [-1.0, 0.0, -s],
        [1.0, 0.0, -s],
        [0.0, 1.0, s],
        [0.0, -1.0, s]])
    f = np.array([[0, 1, 2], [0, 2, 3], [0, 3, 1], [3, 2, 1]])
    v = _align_scale(v, radius, center)
    return v, f


def moebius(
        num_twists=1,  # How many twists are there in the 'paper'?
        nl=60,  # Number of nodes along the length of the strip
        nw=11,  # Number of nodes along the width of the strip (>= 2)
        mode="classical",
):
    """Creates a simplistic triangular mesh on a slightly Möbius strip. The
    Möbius strip here deviates slightly from the ordinary geometry in that it
    is constructed in such a way that the two halves can be exchanged as to
    allow better comparison with the pseudo-Möbius geometry.
    The mode is either `'classical'` or `'smooth'`. The first is the classical
    Möbius band parametrization, the latter a smoothed variant matching
    `'pseudo'`.
    """

    def _create_elements(nl, nw, reverse_seam):
        elems = []
        for i in range(nl - 1):
            for j in range(nw - 1):
                if (i + j) % 2 == 0:
                    elems.append([i * nw + j, (i + 1) * nw + j + 1, i * nw + j + 1])
                    elems.append([i * nw + j, (i + 1) * nw + j, (i + 1) * nw + j + 1])
                else:
                    elems.append([i * nw + j, i * nw + j + 1, (i + 1) * nw + j])
                    elems.append([i * nw + j + 1, (i + 1) * nw + j, (i + 1) * nw + j + 1])

        # close the geometry
        i = nl - 1
        if reverse_seam:
            # Close the geometry upside down (odd Möbius fold)
            for j in range(nw - 1):
                if (i + j) % 2 == 0:
                    elems.append([i * nw + j, (nw - 1) - (j + 1), i * nw + j + 1])
                    elems.append([i * nw + j, (nw - 1) - j, (nw - 1) - (j + 1)])
                else:
                    elems.append([i * nw + j, i * nw + j + 1, (nw - 1) - j])
                    elems.append([i * nw + j + 1, (nw - 1) - j, (nw - 1) - (j + 1)])
        else:
            # Close the geometry upside up (even Möbius fold)
            for j in range(nw - 1):
                if (i + j) % 2 == 0:
                    elems.append([i * nw + j, j + 1, i * nw + j + 1])
                    elems.append([i * nw + j, j, j + 1])
                else:
                    elems.append([i * nw + j, i * nw + j + 1, j])
                    elems.append([i * nw + j + 1, j, j + 1])

        return np.array(elems)

    # The width of the strip
    width = 1.0
    scale = 10.0

    # radius of the strip when flattened out
    r = 1.0

    # seam displacement
    alpha0 = 0.0  # pi / 2

    # How flat the strip will be.
    # Positive values result in left-turning Möbius strips, negative in
    # right-turning ones.
    # Also influences the width of the strip.
    flatness = 1.0

    # Generate suitable ranges for parametrization
    u_range = np.linspace(0.0, 2 * np.pi, num=nl, endpoint=False)
    v_range = np.linspace(-0.5 * width, 0.5 * width, num=nw)

    # Create the vertices. This is based on the parameterization
    # of the Möbius strip as given in
    # <http://en.wikipedia.org/wiki/M%C3%B6bius_strip#Geometry_and_topology>
    sin_u = np.sin(u_range)
    cos_u = np.cos(u_range)
    alpha = num_twists * 0.5 * u_range + alpha0
    sin_alpha = np.sin(alpha)
    cos_alpha = np.cos(alpha)

    if mode == "classical":
        a = cos_alpha
        b = sin_alpha
        reverse_seam = num_twists % 2 == 1
    elif mode == "smooth":
        # The fundamental difference with the ordinary Möbius band here are the
        # squares.
        # It is also possible to to abs() the respective sines and cosines, but
        # this results in a non-smooth manifold.
        a = np.copysign(cos_alpha ** 2, cos_alpha)
        b = np.copysign(sin_alpha ** 2, sin_alpha)
        reverse_seam = num_twists % 2 == 1
    else:
        assert mode == "pseudo"
        a = cos_alpha ** 2
        b = sin_alpha ** 2
        reverse_seam = False

    nodes = (
            scale
            * np.array(
        [
            np.outer(a * cos_u, v_range) + r * cos_u[:, np.newaxis],
            np.outer(a * sin_u, v_range) + r * sin_u[:, np.newaxis],
            np.outer(b, v_range) * flatness,
        ]
    )
            .reshape(3, -1)
            .T
    )

    elems = _create_elements(nl, nw, reverse_seam)
    return nodes, elems


def super_toroid(ringradius=1, crosssectionradius=0.5, xradius=1, yradius=1, zradius=1, n1=1, n2=1):
    """Generate a supertoroid.

    ParametricSuperToroid generates a supertoroid.  Essentially a
    supertoroid is a torus with the sine and cosine terms raised to a power.
    A supertoroid is a versatile primitive that is controlled by four
    parameters r0, r1, n1 and n2. r0, r1 determine the type of torus whilst
    the value of n1 determines the shape of the torus ring and n2 determines
    the shape of the cross section of the ring. It is the different values of
    these powers which give rise to a family of 3D shapes that are all
    basically toroidal in shape.

    Parameters
    ----------
    ringradius : double, optional
        The radius from the center to the middle of the ring of the
      supertoroid. Default is 1.

    crosssectionradius : double, optional
        The radius of the cross section of ring of the supertoroid.
      Default = 0.5.

    xradius : double, optional
        The scaling factor for the x-axis. Default is 1.

    yradius : double, optional
        The scaling factor for the y-axis. Default is 1.

    zradius : double, optional
        The scaling factor for the z-axis. Default is 1.

    n1 : double, optional
        The shape of the torus ring.  Default is 1.

    n2 : double, optional
        The shape of the cross section of the ring. Default is 1.

    """
    supertoroid = pv.ParametricSuperToroid(ringradius=ringradius, crosssectionradius=crosssectionradius,
                                           xradius=xradius,
                                           yradius=yradius, zradius=zradius, n1=n1, n2=n2)
    return pyvista_mesh2numpy(supertoroid)


def icosahedron(radius=1.0, center=DEF_CENTER):
    """
    :return:  icosahedron: http://mathworld.wolfram.com/Icosahedron.html
    """
    r = (1.0 + math.sqrt(5.0)) / 2.0
    v = np.array([
        [-1.0, r, 0.0],
        [1.0, r, 0.0],
        [-1.0, -r, 0.0],
        [1.0, -r, 0.0],
        [0.0, -1.0, r],
        [0.0, 1.0, r],
        [0.0, -1.0, -r],
        [0.0, 1.0, -r],
        [r, 0.0, -1.0],
        [r, 0.0, 1.0],
        [-r, 0.0, -1.0],
        [-r, 0.0, 1.0],
    ], dtype=float)

    f = np.array([
        [0, 11, 5],
        [0, 5, 1],
        [0, 1, 7],
        [0, 7, 10],
        [0, 10, 11],
        [1, 5, 9],
        [5, 11, 4],
        [11, 10, 2],
        [10, 7, 6],
        [7, 1, 8],
        [3, 9, 4],
        [3, 4, 2],
        [3, 2, 6],
        [3, 6, 8],
        [3, 8, 9],
        [5, 4, 9],
        [2, 4, 11],
        [6, 2, 10],
        [8, 6, 7],
        [9, 8, 1],
    ])
    v = _align_scale(v, radius, center)
    return v, f


def dodecahedron(radius=1.0, center=DEF_CENTER):
    """ Generate a regular `dodecahedron`_.
    Args:
        radius float: Radius of the shape.
        center np.ndarray: shape center.
    Returns:
        The dodecahedron http://mathworld.wolfram.com/Dodecahedron.html
    """
    # r = (1.0 + math.sqrt(5.0)) / 2.0;
    v = np.array([
        -0.57735, -0.57735, 0.57735,
        0.934172, 0.356822, 0,
        0.934172, -0.356822, 0,
        -0.934172, 0.356822, 0,
        -0.934172, -0.356822, 0,
        0, 0.934172, 0.356822,
        0, 0.934172, -0.356822,
        0.356822, 0, -0.934172,
        -0.356822, 0, -0.934172,
        0, -0.934172, -0.356822,
        0, -0.934172, 0.356822,
        0.356822, 0, 0.934172,
        -0.356822, 0, 0.934172,
        0.57735, 0.57735, -0.57735,
        0.57735, 0.57735, 0.57735,
        -0.57735, 0.57735, -0.57735,
        -0.57735, 0.57735, 0.57735,
        0.57735, -0.57735, -0.57735,
        0.57735, -0.57735, 0.57735,
        -0.57735, -0.57735, -0.57735,
    ]).reshape((-1, 3), order="C")
    f = np.array([
        19, 3, 2,
        12, 19, 2,
        15, 12, 2,
        8, 14, 2,
        18, 8, 2,
        3, 18, 2,
        20, 5, 4,
        9, 20, 4,
        16, 9, 4,
        13, 17, 4,
        1, 13, 4,
        5, 1, 4,
        7, 16, 4,
        6, 7, 4,
        17, 6, 4,
        6, 15, 2,
        7, 6, 2,
        14, 7, 2,
        10, 18, 3,
        11, 10, 3,
        19, 11, 3,
        11, 1, 5,
        10, 11, 5,
        20, 10, 5,
        20, 9, 8,
        10, 20, 8,
        18, 10, 8,
        9, 16, 7,
        8, 9, 7,
        14, 8, 7,
        12, 15, 6,
        13, 12, 6,
        17, 13, 6,
        13, 1, 11,
        12, 13, 11,
        19, 12, 11,
    ]).reshape((-1, 3), order="C") - 1

    length = norm(v, axis=1).reshape((-1, 1))
    v = v / length * radius + center
    return v, f


def torus(r: float = 1.0, R: float = 2.0, sides: int = 100, rings: int = 100):
    """
    Create vertices and faces for a torus.
    Args:
        r: Inner radius of the torus (Inside Tube)
        R: Outer radius of the torus (Center -> Outside)
        sides: Number of inner divisions.
        rings: Number of outer divisions.
    Returns:
        v,f
    """
    if not (sides > 0):
        raise ValueError("sides must be > 0.")
    if not (rings > 0):
        raise ValueError("rings must be > 0.")

    verts = []
    for i in range(rings):
        # phi ranges from 0 to 2 pi (rings - 1) / rings
        phi = 2 * math.pi * i / rings
        for j in range(sides):
            # theta ranges from 0 to 2 pi (sides - 1) / sides
            theta = 2 * math.pi * j / sides
            x = (R + r * np.cos(theta)) * np.cos(phi)
            y = (R + r * np.cos(theta)) * np.sin(phi)
            z = r * np.sin(theta)
            # This vertex has index i * sides + j
            verts.append([x, y, z])

    faces = []
    for i0, i1 in _make_pair_range(rings):
        index0 = (i0 % rings) * sides
        index1 = (i1 % rings) * sides
        for j0, j1 in _make_pair_range(sides):
            index00 = index0 + (j0 % sides)
            index01 = index0 + (j1 % sides)
            index10 = index1 + (j0 % sides)
            index11 = index1 + (j1 % sides)
            faces.append([index00, index10, index11])
            faces.append([index11, index01, index00])

    v = np.array(verts)
    f = np.array(faces, dtype=np.int32)
    return v, f


# ---------------------------------------------------------------------------------------------------------------------#
#                                               Spheres
# ---------------------------------------------------------------------------------------------------------------------#

def uv_sphere(num_points_per_circle=20, num_circles=10, radius=1.0):
    # Mesh parameters
    n_phi = num_points_per_circle
    n_theta = num_circles

    # Generate suitable ranges for parametrization
    phi_range = np.linspace(0.0, 2 * np.pi, num=n_phi, endpoint=False)
    theta_range = np.linspace(
        -np.pi / 2 + np.pi / (n_theta - 1),
        np.pi / 2 - np.pi / (n_theta - 1),
        num=n_theta - 2,
    )

    num_nodes = len(theta_range) * len(phi_range) + 2
    nodes = np.empty(num_nodes, dtype=np.dtype((float, 3)))
    # south pole
    south_pole_index = 0
    k = 0
    nodes[k] = np.array([0.0, 0.0, -1.0])
    k += 1
    # nodes in the circles of latitude (except poles)
    for theta in theta_range:
        for phi in phi_range:
            nodes[k] = np.array(
                [
                    np.cos(theta) * np.sin(phi),
                    np.cos(theta) * np.cos(phi),
                    np.sin(theta),
                ]
            )
            k += 1
    # north pole
    north_pole_index = k
    nodes[k] = np.array([0.0, 0.0, 1.0])

    nodes *= radius

    # create the elements (cells)
    num_elems = 2 * (n_theta - 2) * n_phi
    elems = np.empty(num_elems, dtype=np.dtype((int, 3)))
    k = 0

    # connections to south pole
    for i in range(n_phi - 1):
        elems[k] = np.array([south_pole_index, i + 1, i + 2])
        k += 1
    # close geometry
    elems[k] = np.array([south_pole_index, n_phi, 1])
    k += 1

    # non-pole elements
    for i in range(n_theta - 3):
        for j in range(n_phi - 1):
            elems[k] = np.array(
                [i * n_phi + j + 1, i * n_phi + j + 2, (i + 1) * n_phi + j + 2]
            )
            k += 1
            elems[k] = np.array(
                [i * n_phi + j + 1, (i + 1) * n_phi + j + 2, (i + 1) * n_phi + j + 1]
            )
            k += 1

    # close the geometry
    for i in range(n_theta - 3):
        elems[k] = np.array([(i + 1) * n_phi, i * n_phi + 1, (i + 1) * n_phi + 1])
        k += 1
        elems[k] = np.array([(i + 1) * n_phi, (i + 1) * n_phi + 1, (i + 2) * n_phi])
        k += 1

    # connections to the north pole
    for i in range(n_phi - 1):
        elems[k] = np.array(
            [
                i + 1 + n_phi * (n_theta - 3) + 1,
                i + n_phi * (n_theta - 3) + 1,
                north_pole_index,
            ]
        )
        k += 1
    # close geometry
    elems[k] = np.array(
        [
            0 + n_phi * (n_theta - 3) + 1,
            n_phi - 1 + n_phi * (n_theta - 3) + 1,
            north_pole_index,
        ]
    )
    k += 1
    assert k == num_elems, "Wrong element count."

    return nodes, elems


def tetrasphere(n):
    corners = np.array(
        [
            [2 * np.sqrt(2) / 3, 0.0, -1.0 / 3.0],
            [-np.sqrt(2) / 3, np.sqrt(2.0 / 3.0), -1.0 / 3.0],
            [-np.sqrt(2) / 3, -np.sqrt(2.0 / 3.0), -1.0 / 3.0],
            [0.0, 0.0, 1.0],
        ]
    )
    faces = [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)]

    vertices, cells = _compose_from_faces(corners, faces, n)

    # push all nodes to the sphere
    norms = np.sqrt(np.einsum("ij,ij->i", vertices, vertices))
    vertices = (vertices.T / norms.T).T

    return vertices, cells


def octasphere(n):
    corners = np.array(
        [
            [1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, -1.0, 0.0],
            [0.0, 0.0, 1.0],
            [0.0, 0.0, -1.0],
        ]
    )
    faces = [
        (0, 2, 4),
        (1, 2, 4),
        (1, 3, 4),
        (0, 3, 4),
        (0, 2, 5),
        (1, 2, 5),
        (1, 3, 5),
        (0, 3, 5),
    ]
    v, f = _compose_from_faces(corners, faces, n)
    # push all nodes to the sphere
    norms = np.sqrt(np.einsum("ij,ij->i", v, v))
    v = (v.T / norms.T).T

    return v, f


def icosphere(refinement_order=1, radius=1.0, center=DEF_CENTER):
    """ Generate icosphere (subdivision surface of a icosahedron).
    Args:
        radius float: Radius of icosphere.
        center np.ndarray: Sphere center.
        refinement_order int: (optional) Order of refinement.
    Returns:
        The (possibly refined) icosphere
    """
    assert (isinstance(radius, Number))
    assert (center.shape == (3,))

    v, f = subdivide(*icosahedron(), refinement_order)
    v = _align_scale(v, radius, center)
    return v, f


def four_simplex_cone():
    nodes = np.array(
        [
            [+0.0, +0.0, 1.0],
            [+1.0, +0.0, 0.0],
            [+0.0, +1.0, 0.0],
            [-1.0, +0.0, 0.0],
            [+0.0, -1.0, 0.0],
        ]
    )
    elems = np.array([[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1]])
    return nodes, elems


# function [M] = peak(n)
# if ~exist('n','var'); n = 200; end
# [x,y,z] = peaks(n); % Built-in Matlab function
# [f,v] = surf2patch(x,y,z,'triangles');
# % tri = delaunay(x(:),y(:),z(:));
# M = Mesh(v,f,sprintf('peaks-%d',n),which(mfilename));
# end


# ---------------------------------------------------------------------------------------------------------------------#
#
# ---------------------------------------------------------------------------------------------------------------------#
def _icosphere_montage(n=6):
    from geom.mesh.vis.base import plot_mesh_montage
    vs, fs = [], []
    for i in range(n):
        v, f = icosphere(refinement_order=i)
        vs.append(v)
        fs.append(f)
    plot_mesh_montage(vs, fs, strategy='wireframe')


def _tester():
    from geom.mesh.vis.base import plot_mesh

    plot_mesh(*torus(sides=5, rings=5), strategy='wireframe')
    plot_mesh(*dodecahedron(), strategy='wireframe')
    plot_mesh(*icosahedron(), strategy='wireframe')
    plot_mesh(*tetrahedron(), strategy='wireframe')
    _icosphere_montage(6)


# ---------------------------------------------------------------------------------------------------------------------#
#
# ---------------------------------------------------------------------------------------------------------------------#
if __name__ == '__main__':
    v,f = uniform_grid(cell_type='tris',nx=10,ny=20)
    from geom.mesh.vis.base import plot_mesh

    # v, f = super_toroid(n1=0.5)
    plot_mesh(v, f, strategy='mesh', clr='tan',show_edges=True)
    pass
    # plot_mesh(*cylinder(), strategy='wireframe')
